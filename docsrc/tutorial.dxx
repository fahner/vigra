/** \page Tutorial Tutorial
    
    This tutorial will help you to get to know the most important methods of VIGRA and 
	shows you how to use them by giving some simple examples. The tutorial consists of
	the following parts:
    
    <ul>
    
    <li> The idea of VIGRA an the MultiArray class
    
    <li> \ref Indexing
		<BR>&nbsp;&nbsp;&nbsp;<em>how to access an element of MultiArray</em>
    
    <li> Important methods
		<BR>&nbsp;&nbsp;&nbsp;<em>the methods subarray, bind and transpose</em>
      
    </ul>
*/

/** \page Indexing Indexing
	There are different ways to access the elements of a MultiArray. The first way is to
 	use the []-Operator:
    
    <h2> []-Operator an StridedScanOrderIterator </h2>
	
    \code
		#include <vigra/multi_array.hxx>
		#include <iostream>

		using namespace vigra;

		int main (int argc, char ** argv) {
	
		    // declare 2-dimensional MultiArray with 3 integer elements in first dimension  
		    // and 2 integer elements in second dimension
		    vigra::MultiArray<2, int> intArray(Shape2(3,2));
	
		    // set all elements on 3
		    intArray.init(3);

		    // print the first element on console
            std::cout << intArray[0] << std::endl;

            return 0;
		}
	\endcode
	
	The access via \code intArray[0] \endcode is equivalent to the StridedScanOrderIterator.
	Scan order means, that you iterate the dimensions from front to back. You can easily 
	build instances of this Iterator by calling the MultiArrayView::begin() and 
	MultiArrayView::end() methods. To give an example we iterate over all elements and set a
	new value:

	\code
		// declare iterator
		vigra::MultiArray<2, int>::iterator iter;
		int count = 0;
		// iterate over intArray, set a new value and print the element
		for (iter = intArray.begin(); iter != intArray.end(); iter++) {
			*iter = ++count;
			std::cout << *iter << std::endl;
		}
	\endcode

	Let's do some maths: We use the MultiArray class to represent matrices and want to add
	two 3x3-matrices by adding the elements on the same position. The result will be stored
	in the first matrix. We can implement the addition like this:

	\code
		vigra::MultiArray<2, int> matrix1(Shape2(3,3));
		vigra::MultiArray<2, int> matrix2(Shape2(3,3));
		matrix1.init(1);
		matrix2.init(3);
	
		int elements = matrix1.size();			// number of array elements
		for (int i=0; i < elements; i++) {
			matrix1[i] += matrix2[i];
		}
	\endcode

	Be careful: The StridedScanOrderIterator doesn't regard the shape and the strides of the
	MultiArray. Imagine you are adding a 2x3-matrix and a 3x2-matrix.

	\code
		vigra::MultiArray<2, int> _23Matrix(Shape2(2,3));
		vigra::MultiArray<2, int> _32Matrix(Shape2(3,2));
		_23Matrix.init(1);
		_32Matrix.init(3);
	
		int size = _23Matrix.size();			// number of array elements
		for (int i=0; i < size; i++) {
			_23Matrix[i] += _32Matrix[i];
		}
	\endcode

	<B> This implementation works but it's mathematically impossible! </B>

    By the way: VIGRA provides the += Operator for this purpose and throws an exception if 
    the matrix-sizes don't match:

    \code
        matrix1 += matrix2;                     // works fine!
        _23Matrix += _32Matrix;                 // error: wrong matrix sizes!
    \endcode

    <h2> Access via coordinates </h2>
    Regarding matrices it is more common to index the elements with a tuple of coordinates.
    Using the matrices from the section above we can access for instance the element of 
    <dfn> matrix1 </dfn> in the second column and third row by using round brackets 
    ():

    \code
        // print element in second column and third row
        std::cout << matrix1(1,2) << std::endl;
    \endcode
	
	In combination with the method size(n), that gives us the size of the n-th dimension, 
    we can use the coordinates to set the element of an entire row or column:

    \code
        // set all elements of second row to 13
        for (int i = 0; i < _23Matrix.size(1); i++) {
            _23Matrix(1,i) = 13;
        }
    \endcode

    Later in this tutorial, we will discuss special methods to set certain parts of the array.

    An alternative way of indexing with coordinates is the use of the MultiArrayShape::type, 
    which is a kind of a TinyVector. This way is equivalent to the round brackets. For this 
    example we use the type Shape2(x,y), the specific type definition for 2-dimensional
    arrays.

    \code
        // access via Shape2(x,y), set element in second column and third row
        matrix1[Shape2(1,2)] = 22;
    \endcode
*/
