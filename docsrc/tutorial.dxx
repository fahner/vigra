/** \page Tutorial Tutorial
    
    This tutorial will help you to get to know the most important methods of VIGRA and 
	shows you how to use them by giving some simple examples. The tutorial consists of
	the following parts:
    
    <ul>
    
    <li> \ref Basics
    
    <li> \ref Indexing
		<BR>&nbsp;&nbsp;&nbsp;<em>how to access an element of MultiArray</em>

    <li> \ref ImageInputOutput
    
    <li> \ref ImportantMethods
		<BR>&nbsp;&nbsp;&nbsp;<em>the methods bind and subarray</em>

    <li> \ref MultiMathModule
    </ul>
*/

/** \page Basics Basic ideas
    <p>The aim of this tutorial is to show you some easy examples of Image Processing using 
    arrays, particularly VIGRA's MultiArray. An image can be interpreted as a matrix or
    2-dimensional arrays, where each element contains the information of a specific pixel.
    In fact, matrices or 2-dimensional arrays are implemented as 1-dimensional array, but for 
    us it seems more natural to describe an image by 2 coordinates (ergo dimensions).
    Each pixel of an image with 800x600 pixels can be identified by a pair (y,x) with 
    y = 0,...,799 and x = 0,...,599.</p>
    <p> In VIGRA, we call the structure of the matrix or multidimensional array 
    <dfn>shape</dfn>. The image described above has the shape (800,600). A 3x3-matrix has the 
    shape (3,3).
    Shapes like (n,m, ...) define the possible values of the coordinates for each 
    dimension: <br/>
    possible coordinates in dimension 0: 0, 1, ..., n-1 <br/>
    possible coordinates in dimension 1: 0, 1, ..., m-1 <br/>
    ... </p>
    <p> To represent the data of a gray scale image, we just need to store one value, so we 
    choose a 2-dimensional array, where each element has the <dfn> unsigned char </dfn> type. 
    With VIGRA we instantiate an gray scale image object like this:</p>
    
    \code
        #include <vigra/multi_array.hxx>
        vigra::MultiArray<2, unsigned char> imageArray;
    \endcode

    <p> Considering RGB-images it is obvious that we can't use the unsigned char type to store
    color images because every pixel contains 3 informations: values for red, green and blue.
    Mathematically you intend to store the data in a vector. For this special purpose, VIGRA
    provides the <dfn>vigra::RGBValue<ValueType></dfn> class. So for RGB-images just use: </p>

    \code
        vigra::MultiArray<2, vigra::RGBValue<unsigned char> > RGBImageArray;
    \endcode

    In fact, vigra::RGBValue<ValueType> is a special kind of a 3-dimensional vector
    containing ValueType elements. The vector data type in VIGRA is implemented in the
    <dfn> TinyVector<T, SIZE> </dfn> class.

    Alternatively you can use a 3-dimensional array <dfn>vigra::MultiArray<2, unsigned
    char></dfn> to represent a color image. The third dimension has size 3 and contains the
    information for red, green and blue channel. We won't use the 3-dimensional array for
    color images because dfn>vigra::RGBValue<ValueType></dfn> provides a lot of helpful
    methods.

    Maybe you've recognized in the last paragraph that there is no need to restrict oneself
    to 2-dimensional arrays. With VIGRA an <B>arbitrary number of dimensions</B> is possible
    for instance:

    \code
        vigra::MultiArray<7, float> otherArray;
    \endcode
*/
/** \page Indexing Indexing

    <h2> Access via coordinates </h2>

    Regarding matrices it is common to index the elements with a tuple of coordinates.
    Using a 3x2 matrix from the section above we can access for instance the element of 
    <dfn> matrix </dfn> in the second column and third row by using the MultiArrayShape::type, 
    which is a kind of a TinyVector. For this example we use the type Shape2(x,y), the 
    specific type definition for 2-dimensional arrays.

    \code
        #include <vigra/multi_array.hxx>
        #include <iostream>
        
        using namespace vigra;
        
        int main (int argc, char ** argv) {
        
            // declare 2-dimensional MultiArray with 3 integer elements in first dimension  
            // and 2 integer elements in second dimension
            vigra::MultiArray<2, int> matrix(Shape2(2,3));
        
            // set all elements on 3
            matrix.init(3);
        
            // print element in second column and third row
            std::cout << matrix[Shape2(1,2)] << std::endl;      // output: 3

            return 0;
        }
    \endcode

    An easier and equivalent way is just to use the coordinates with round brackets (y,x):

    \code
        // access via simple coordinates, set element in second column and third row
        matrix1(1,2) = 22;
    \endcode
	
	In combination with the method size(n), that gives us the size of the n-th dimension, 
    we can use the coordinates to set the element of an entire row or column:

    \code
        // set all elements of second row to 13
        for (int i = 0; i < matrix.size(1); i++) {
            matrix(1,i) = 13;
        }
    \endcode

    Every call with round brackets creates a new Shape-Object, which is quite inefficient.
    It is better to iterate over a Shape-Object. In the following example, we want to set the
    3rd column of a 8x4-matrix (initialized with 5) to 7.

    \code
        // iterating over a Shape-Object
        vigra::MultiArray<2, int> matrix84(Shape2(4,8));
        matrix84.init(5);
        // instantiate Shape-Object
        Shape2 p;
        // iterate over 3rd column :
        // set first dimension on 2 (equals 3rd column)
        // then iterate over second dimension (equals rows)
        p[0] = 2;                                  
        for(p[1]=0; p[1]<matrix84.size(1); p[1]++) {   
            matrix84[p] = 7;
        }
    \endcode

    Later in this tutorial, we will discuss special methods to set certain parts of the array.

    <hr>

    <h2> []-Operator and StridedScanOrderIterator </h2>
	
    \code
        #include <vigra/multi_array.hxx>
        #include <iostream>
        
        using namespace vigra;
        
        int main (int argc, char ** argv) {
        
            // declare 2-dimensional MultiArray with 3 integer elements in first dimension  
            // and 2 integer elements in second dimension
            vigra::MultiArray<2, int> intArray(Shape2(3,2));
        
            // set all elements on 3
            intArray.init(3);
        
            // print the first element on console
            std::cout << intArray[0] << std::endl;
        
            return 0;
        }
    \endcode
	
	The access via <dfn> intArray[0] </dfn> refers to the the index of the scan order.
	Scan order means, that you iterate the dimensions from front to back. The <dfn> 
    vigra::MultiArray </dfn> - class provides methods to determine the scan order index of 
    given coordinates and vice versa. The <dfn>StridedScanOrderIterator</dfn> lets you iterate
    over the array elements in scan order. You can easily build instances of this Iterator 
    by calling the <dfn>MultiArrayView::begin()</dfn> and <dfn>MultiArrayView::end()</dfn> 
    methods. To give an example we iterate over all elements and set a new value:

	\code
		// declare iterator
		vigra::MultiArray<2, int>::iterator iter;
		int count = 0;
		// iterate over intArray, set a new value and print the element
		for (iter = intArray.begin(); iter != intArray.end(); iter++) {
			*iter = ++count;
		    std::cout << *iter << " ";
	    }
        std::cout << std::endl;
	\endcode

    This creates the ouptut:

    \verbatim
        1 2 3 4 5 6
    \endverbatim

	Let's do some maths: We use the MultiArray class to represent matrices and want to add
	two 3x3-matrices by adding the elements on the same position. The result will be stored
	in the first matrix. We can implement the addition like this:

	\code
		vigra::MultiArray<2, int> matrix1(Shape2(3,3));
		vigra::MultiArray<2, int> matrix2(Shape2(3,3));
		matrix1.init(1);
		matrix2.init(3);
	
		int elements = matrix1.size();			// number of array elements
		for (int i=0; i < elements; i++) {
			matrix1[i] += matrix2[i];
		}
	\endcode

	Be careful: The StridedScanOrderIterator doesn't recognize if the matrices' shapes match
    to each other.

	\code
	    vigra::MultiArray<2, int> matrix32(Shape2(2,3));
	    vigra::MultiArray<2, int> matrix23(Shape2(3,2));
	    matrix32.init(1);
        matrix23.init(3);
	
	    int size = matrix32.size();			// number of array elements
	    for (int i=0; i < size; i++) {
		    matrix32[i] += matrix23[i];
        }
	\endcode

	<B> This implementation works but it's probably not what you're mathematically intending
    to do! </B>

    By the way: VIGRA provides the += Operator for this purpose and throws an exception if 
    the matrix-sizes don't match:

    \code
        matrix1 += matrix2;                     // works fine!
        matrix32 += matrix23;                 // error: wrong matrix sizes!
    \endcode

    For further mathematical implementations see \ref MultiMathModule .

    VIGRA's scan order is similar to the NumPy-method <dfn> array.flatten </dfn>. You use it, 
    to copy a multidimensional array into an one-dimensional array. The only
    difference is that NumPy uses "C-order" (that means the outmost dimension first), but
    VIGRA from first to last dimension. A method like flatten can be implemented in VIGRA like
    this:

    \code
        // initialize array for flattening
        // set first row of matrix23 to 1 2 3, second row to 4 5 6
        count = 0;
        for (iter = matrix23.begin(); iter != matrix23.end(); iter++) {
            *iter = count++;
        }

        // flatten an array in scan order
        // create 1D-array of appropriate size
        vigra::MultiArray<1, int> flatArray(Shape1(matrix23.size()));
        // copy 2D-array into 1D-array
        std::copy(matrix23.begin(), matrix23.end(), flatArray.begin());
        
        // print 1D-array on console; 
        for (iter = flatArray.begin(); iter != flatArray.end(); iter++) {
             std::cout << *iter << " ";
        }
        std::cout << std::endl;
    \endcode

    To show the difference between VIGRA and NumPy we'll we add the NumPy output if we had
    used the flatten-method to the output of the code above

    \verbatim
    flatarray - index     0       1       2       3       4       5 
    -----------------------------------------------------------------
    VIGRA-output:         0       1       2       3       4       5
    matrix23 - index    [0,0]   [1,0]   [2,0]   [0,1]   [1,1]   [2,1]
    -----------------------------------------------------------------
    NumPy-output:         0       3       1       4       2       5
    matrix23 - index    [0,0]   [0,1]   [1,0]   [1,1]   [2,0]   [2,1]
    \endverbatim

   However, NumPy's flat-method returns an iterator like matrix23.begin() in VIGRA.
*/


/** \page ImportantMethods Important Methods
    In this part of the tutorial we'll introduce you to some important methods.

    <h2> bind<M>(i) </h2>
    This method is part of the MultiArrayView-Class and binds the dimension M to the index d.
    As you probably remember, we tried to set the elements of a certain column or row of a 
    matrix in the \ref Indexing part. We used a for-loop, but it's getting more easily with
    the bind-method. Look at the following example. We initialize a 2x3-matrix with the value
    0, set the second row to 5 and print the array eventually:

    \code
        #include <vigra/multi_array.hxx>
        #include <iostream>

        using namespace vigra;

        int main (int argc, char ** argv) {
            // initialize 2x3-matrix and declare iterator
            vigra::MultiArray<2, int> intArray(Shape2(3,2));
            intArray.init(0);
            vigra::MultiArray<2, int>::iterator iter;

            // set 2nd row (equivalent to dimension 1 and index 1) to 5
            intArray.bind<1>(1) = 5;

            // print the array on console
            for (iter = intArray.begin(); iter != intArray.end(); iter++) {
		        std::cout << *iter << "  ";
	        }
            std::cout << std::endl;

            return 0;
        }
    \endcode

    The output is:

    \verbatim
    0  0  0  5  5  5
    \endverbatim

    Binding a dimension reduces a N-dimensional array to dimension N-1. Furthermore you can
    initialize a lower-dimensional array with the bind-method.

    \code
        // initialize new array with 3rd column of intArray
        vigra::MultiArray<1, int> lowArray = intArray.bind<0>(2);
    \endcode

    The array <dfn> lowArray </dfn> contains the elements the 3rd column of intArray. At this
    point we have to distinguish between the classes <dfn> MultiArray </dfn> and 
    <dfn> MultiArrayView </dfn>. MultiArray inherits from MultiArrayView and contains the
    memory management of the array. With MultiArrayView we can view the data stored in a 
    MultiArray. The code above produces a copy of the 3rd column of intArray. If we change the
    elements of <dfn>lowArray</dfn> nothing happens to <dfn> intArray </dfn>.

    \code
        // initialize new array with 3rd column of intArray
        vigra::MultiArray<1, int> lowArray = intArray.bind<0>(2);
        // set elements of lowArray to ten
        lowArray = 10;
        // print lowArray
        std::cout << "lowArray:\n";
        for (iter = lowArray.begin(); iter != lowArray.end(); iter++) {
		    std::cout << *iter << "  ";
	    }
        std::cout << std::endl;
        // print intArray
        std::cout << "intArray after changing lowArray:\n";
        for (iter = intArray.begin(); iter != intArray.end(); iter++) {
		    std::cout << *iter << "  ";
	    }
        std::cout << std::endl;
    \endcode

    Output:
    \verbatim
    lowArray:
    10  10  
    intArray after changing lowArray:
    0  0  0  5  5  5  
    \endverbatim

    But if we use bind in combination with MultiArrayView instead, we don't get a copy of
    intArray's 3rd column, rather a view of it:

    \code
        // initialize array view of 3rd column of intArray
        vigra::MultiArrayView<1, int, StridedArrayTag> lowArrayView = intArray.bind<0>(2);
        // initialize ArrayView-Iterator
        vigra::MultiArrayView<1,int>::iterator viewIter;
        // set elements of lowArrayView to ten
        lowArrayView = 10;
        // print lowArrayView
        std::cout << "lowArrayView:\n";
        for (viewIter = lowArrayView.begin(); viewIter != lowArrayView.end(); viewIter++) {
		    std::cout << *viewIter << "  ";
	    }
        std::cout << std::endl;
        // print intArray
        std::cout << "intArray after changing lowArrayView:\n";
        for (iter = intArray.begin(); iter != intArray.end(); iter++) {
		    std::cout << *iter << "  ";
	    }
        std::cout << std::endl;
    \endcode

    Output:
    \verbatim
    lowArrayView:
    10  10  
    intArray after changing lowArrayView:
    0  0  10  5  5  10 
    \endverbatim

    In this case, changing lowArrayView causes changes in intArray because we changed a view
    of intArray and not a copy. An equivalent and easier way to change the 3rd column is
    analogous to the first example:

    \code
        // set 3rd column to ten
        intArray.bind<0>(2) = 10;
    \endcode

    Moving on to Image Processing we'll give an example how you can flip an image by using 
    bind. We save an gray scale image in a 2-dimensional array called <dfn> imageArray </dfn>. 
    Then we initalize a new array <dfn> newImageArray </dfn> of the same dimension and size
    and set the first row of <dfn> newImageArray </dfn> to the values of the last row of 
    <dfn> imageArray </dfn>, the second row to the values of the second last row and so on.
    Hence, we flip the image top to bottom.

    \code
        #include <iostream>
        #include <vigra/multi_array.hxx>
        #include "vigra/stdimage.hxx"
        #include "vigra/impex.hxx"

        using namespace vigra; 


        int main(int argc, char ** argv) {
            if(argc != 3) {
                std::cout << "Usage: " << argv[0] << " infile outfile" << std::endl;
                std::cout << "(supported formats: " << vigra::impexListFormats() << ")" << std::endl;
                
                return 1;
            }

            try {
                vigra::ImageImportInfo info(argv[1]);
                
                if(info.isGrayscale()) {
			        vigra::MultiArray<2, unsigned char> imageArray(Shape2(info.width(), info.height()));
			        importImage(info, destImage(imageArray));
                    vigra::MultiArray<2, unsigned char> newImageArray(Shape2(info.width(), info.height()));
                    
                    // mirror the image horizontal 
                    // info.height() is equal to the index of the last row
			        for (int i=0; i<=info.height(); i++) {           
	                		newImageArray.bind<1>(i) = imageArray.bind<1>(info.height()-(i+1));
			        }
                    
                    exportImage(srcImageRange(newImageArray), vigra::ImageExportInfo(argv[2]));
                }
                else {
                    std::cout << "no gray scale image" << std::endl;
                }
            }
            catch (vigra::StdException & e) {
                std::cout << e.what() << std::endl;
                return 1;
            }
            
            return 0;
        }
    \endcode
    
    This code needs an infile and an outfile as arguments. For this example, just the 
    commented for-loop is important. The rest contains the code for
    \ref ImageInputOutput and is explained in this part of the Tutorial. We bind dimension 1
    to fix the y-coordinate. To flip left to right you have to fix the x-coordinate, so bind
    dimension 0. <br/>
    Here you can see what happens to an inputfile:

    \image html lenna_small.gif "inputfile"
    \image html lenna_mirror.gif "mirrored outputfile"

    A detailed example is given here:
    <a href="mirror_8cxx-example.html">mirror.cxx</a> 
    There you can flip RGB-images as well and decide wheter to flip top to bottom (horizontal)
    or left to right (vertical).
    
    <hr>

    <h2> subarray(p,q) </h2>
    This method is part of the MultiArrayView-Class and creates a rectangular subarray of your
    array between the points p and q, where p is included, q not. Compared to the <dfn>bind
    </dfn>-method, subarray doesn't change the dimension.
    To give an example, let's say that you want to copy the upper-left subsquare of a 
    4x4-matrix (initialized with 1).

    \code
        // copy the upper-left subsquare of a 4x4-matrix
        vigra::MultiArray<2, int> _44Matrix(Shape2(4,4));
        _44Matrix.init(1);
        vigra::MultiArray<2, int> subsquare = _44Matrix.subarray(Shape2(0,0), Shape2(2,2));
    \endcode

    To determine the positions p and q, we use <dfn>Shape</dfn>. In this example we copy the 
    element with the x,y-coordinates from 0 to 1. Subarray can be used to set elements as
    well. We now set the lower half of the 4x4-matrix to 0.

    \code
       // change the elements of a subarray
       _44Matrix.subarray(Shape2(0,2),Shape2(4,4)) = 0;
    \endcode

    In Image Processing you can use <dfn>subarray</dfn> to create a subimage of a given image.
    In the next example we create a half-sized subimage with the middle part of the original
    image:
    <a href="subimage_tutorial_8cxx-example.html">subimage_tutorial.cxx</a> <br />
    The relevant part ot this code is shown here:

    \dontinclude subimage_tutorial.cxx
    \skip // write
    \until exportImage

    After writing the (here: gray scale) image data to an array we need to calculate the 
    coordinates of our subimage. In this case we want to cut out the middle part of the image. 
    Afterwards we write the subimage into a new array. Look at the results.

    \image html lenna_small.gif "inputfile"
    \image html lenna_sub.gif "subimage outputfile"
*/

/** \example mirror.cxx
    Mirror an image file (horizontal or vertical)
    <br>
    Usage: <TT>mirror infile outfile</TT>
*/

/** \example subimage_tutorial.cxx
    Create a half-sized subimage
    <br>
    Usage: <TT>mirror infile outfile</TT>
*/

/** \page ImageInputOutput Image Input Output 
    In this chapter we'd like to show you how to import and export an image with Vigra. If you
    you want to import an image from disk and enquire about its properties, you must use an 
    object of <dfn> ImageImportInfo </dfn> class. The constructor expects the filename, the
    filename will be determined automatically.
    In the following example, the image is given via console as first argument:

    \include imageImportInfo_tutorial.cxx

    As you can see, the <dfn> ImageImportInfo </dfn> object contains a lot of information,
    some of it is printed in the example.

    To process images, this isn't enough. As described in \ref basics we want to save the
    image data in a multidimensional array. That's why we need <dfn> MultiArray </dfn> 
    object and a method writing the image data into the array. This method is called 
    <dfn> vigraImportImage(...) </dfn>. It needs an <dfn> ImageImportInfo </dfn> object and
    
*/
