/** \page Tutorial Tutorial
    
    This tutorial will help you to get to know the most important methods of VIGRA and 
	shows you how to use them by giving some simple examples. The tutorial consists of
	the following parts:
    
    <ul>
    
    <li> \ref Basics
    
    <li> \ref Indexing
		<BR>&nbsp;&nbsp;&nbsp;<em>how to access an element of MultiArray</em>

    <li> \ref ImageInputOutput
    
    <li> \ref ImportantMethods
		<BR>&nbsp;&nbsp;&nbsp;<em>the methods bind and subarray</em>
      
    </ul>
*/

/** \page Basics Basic ideas
    <p>The aim of this tutorial is to show you some easy examples of Image Processing using 
    arrays, particularly VIGRA's MultiArray. An image can be interpreted as a matrix or
    2-dimensional arrays, where each element contains the information of a specific pixel.
    In fact, matrices or 2-dimensional arrays are implemented as 1-dimensional array, but for 
    us it seems more natural to describe an image by 2 coordinates (ergo dimensions).
    Each pixel of an image with 800x600 pixels can be identified by a pair (y,x) with 
    y = 0,...,799 and x = 0,...,599.</p>
    <p> In VIGRA, we call the structure of the matrix or multidimensional array 
    <dfn>shape</dfn>. The image described above has the shape (800,600). A 3x3-matrix has the 
    shape (3,3).
    Shapes like (n,m, ...) define the possible values of the coordinates for each 
    dimension: <br/>
    possible coordinates in dimension 0: 0, 1, ..., n-1 <br/>
    possible coordinates in dimension 1: 0, 1, ..., m-1 <br/>
    ... </p>
    <p> To save the data of a gray scale image, we just need to store one value, so we choose
    a 2-dimensional array, where each element has the <dfn> unsigned char </dfn> type. With
    VIGRA we instantiate an gray scale image object like this:</p>
    
    \code
        #include <vigra/multi_array.hxx>
        vigra::MultiArray<2, unsigned char> imageArray;
    \endcode

    <p> Considering RGB-images it is obvious that we can't use the unsigned char type to store
    color images because every pixel contains 3 informations: values for red, green and blue.
    Mathematically you intend to store the data in a vector. For this special purpose, VIGRA
    provides the <dfn>vigra::RGBValue<ValueType></dfn> class. So for RGB-images just use: </p>

    \code
        vigra::MultiArray<2, vigra::RGBValue<unsigned char> > RGBImageArray;
    \endcode

    <p> In fact, vigra::RGBValue<ValueType> is a special kind of a 3-dimensional vector
    containing ValueType elements. The vector data type in VIGRA is implemented in the
    <dfn> TinyVector<T, SIZE> </dfn> class.
*/
/** \page Indexing Indexing
	There are different ways to access the elements of a MultiArray. The first way is to
 	use the []-Operator:
    
    <h2> []-Operator an StridedScanOrderIterator </h2>
	
    \code
        #include <vigra/multi_array.hxx>
        #include <iostream>
        
        using namespace vigra;
        
        int main (int argc, char ** argv) {
        
            // declare 2-dimensional MultiArray with 3 integer elements in first dimension  
            // and 2 integer elements in second dimension
            vigra::MultiArray<2, int> intArray(Shape2(3,2));
        
            // set all elements on 3
            intArray.init(3);
        
            // print the first element on console
            std::cout << intArray[0] << std::endl;
        
            return 0;
        }
    \endcode
	
	The access via <dfn> intArray[0] </dfn> is implemented by the StridedScanOrderIterator.
	Scan order means, that you iterate the dimensions from front to back. You can easily 
	build instances of this Iterator by calling the MultiArrayView::begin() and 
	MultiArrayView::end() methods. To give an example we iterate over all elements and set a
	new value:

	\code
		// declare iterator
		vigra::MultiArray<2, int>::iterator iter;
		int count = 0;
		// iterate over intArray, set a new value and print the element
		for (iter = intArray.begin(); iter != intArray.end(); iter++) {
			*iter = ++count;
			std::cout << *iter << std::endl;
		}
	\endcode

	Let's do some maths: We use the MultiArray class to represent matrices and want to add
	two 3x3-matrices by adding the elements on the same position. The result will be stored
	in the first matrix. We can implement the addition like this:

	\code
		vigra::MultiArray<2, int> matrix1(Shape2(3,3));
		vigra::MultiArray<2, int> matrix2(Shape2(3,3));
		matrix1.init(1);
		matrix2.init(3);
	
		int elements = matrix1.size();			// number of array elements
		for (int i=0; i < elements; i++) {
			matrix1[i] += matrix2[i];
		}
	\endcode

	Be careful: The StridedScanOrderIterator doesn't regard the shape and the strides of the
	MultiArray. Imagine you are adding a 2x3-matrix and a 3x2-matrix.

	\code
	    vigra::MultiArray<2, int> _23Matrix(Shape2(2,3));
	    vigra::MultiArray<2, int> _32Matrix(Shape2(3,2));
	    _23Matrix.init(1);
        _32Matrix.init(3);
	
	    int size = _23Matrix.size();			// number of array elements
	    for (int i=0; i < size; i++) {
		    _23Matrix[i] += _32Matrix[i];
        }
	\endcode

	<B> This implementation works but it's mathematically impossible! </B>

    By the way: VIGRA provides the += Operator for this purpose and throws an exception if 
    the matrix-sizes don't match:

    \code
        matrix1 += matrix2;                     // works fine!
        _23Matrix += _32Matrix;                 // error: wrong matrix sizes!
    \endcode

    <hr>

    <h2> Access via coordinates </h2>
    Regarding matrices it is more common to index the elements with a tuple of coordinates.
    Using the matrices from the section above we can access for instance the element of 
    <dfn> matrix1 </dfn> in the second column and third row by using round brackets 
    ():

    \code
        // print element in second column and third row
        std::cout << matrix1(1,2) << std::endl;
    \endcode
	
	In combination with the method size(n), that gives us the size of the n-th dimension, 
    we can use the coordinates to set the element of an entire row or column:

    \code
        // set all elements of second row to 13
        for (int i = 0; i < _23Matrix.size(1); i++) {
            _23Matrix(1,i) = 13;
        }
    \endcode

    Later in this tutorial, we will discuss special methods to set certain parts of the array.

    An alternative way of indexing with coordinates is the use of the MultiArrayShape::type, 
    which is a kind of a TinyVector. This way is equivalent to the round brackets. For this 
    example we use the type Shape2(x,y), the specific type definition for 2-dimensional
    arrays.

    \code
        // access via Shape2(x,y), set element in second column and third row
        matrix1[Shape2(1,2)] = 22;
    \endcode
*/


/** \page ImportantMethods Important Methods
    In this part of the tutorial we'll introduce you to some important methods.

    <h2> bind<M>(i) </h2>
    This method is part of the MultiArrayView-Class and binds the dimension M to the index d.
    As you probably remember, we tried to set the elements of a certain column or row of a 
    matrix in the \ref Indexing part. We used a for-loop, but it's getting more easily with
    the bind-method. Look at the following example. We initialize a 2x3-matrix with the value
    0, set the second row to 5 and print the array eventually:

    \code
        #include <vigra/multi_array.hxx>
        #include <iostream>

        using namespace vigra;

        int main (int argc, char ** argv) {
            // initialize 2x3-matrix and declare iterator
            vigra::MultiArray<2, int> intArray(Shape2(3,2));
            intArray.init(0);
            vigra::MultiArray<2, int>::iterator iter;

            // set 2nd row (equivalent to dimension 1 and index 1) to 5
            intArray.bind<1>(1) = 5;

            // print the array on console
            for (iter = intArray.begin(); iter != intArray.end(); iter++) {
		        std::cout << *iter << "  ";
	        }
            std::cout << std::endl;

            return 0;
        }
    \endcode

    Binding a dimension reduces a N-dimensional array to dimension N-1. Furthermore you can
    initialize a lower-dimensional array with the bind-method.

    \code
        // initialize new array with 3rd column of intArray
        vigra::MultiArray<1, int> lowArray = intArray.bind<0>(2);
    \endcode

    The array <dfn> lowArray </dfn> contains the elements the 3rd column of intArray. Moving
    on to Image Processing we'll give an example how you can mirror an image by using bind.
    We save an gray scale image in a 2-dimensional array called <dfn> imageArray </dfn>. 
    Then we initalize a new array <dfn> newImageArray </dfn> of the same dimension and size
    and set the first row of <dfn> newImageArray </dfn> to the values of the last row of 
    <dfn> imageArray </dfn>, the second row to the values of the second last row and so on.
    Hence, we mirror the image horizontal.

    \code
        #include <iostream>
        #include <vigra/multi_array.hxx>
        #include "vigra/stdimage.hxx"
        #include "vigra/impex.hxx"

        using namespace vigra; 


        int main(int argc, char ** argv) {
            if(argc != 3) {
                std::cout << "Usage: " << argv[0] << " infile outfile" << std::endl;
                std::cout << "(supported formats: " << vigra::impexListFormats() << ")" << std::endl;
                
                return 1;
            }

            try {
                vigra::ImageImportInfo info(argv[1]);
                
                if(info.isGrayscale()) {
			        vigra::MultiArray<2, unsigned char> imageArray(Shape2(info.width(), info.height()));
			        importImage(info, destImage(imageArray));
                    vigra::MultiArray<2, unsigned char> newImageArray(Shape2(info.width(), info.height()));
                    
                    // mirror the image horizontical 
                    // info.height() is equal to the index of the last row
			        for (int i=0; i<=info.height(); i++) {           
	                		newImageArray.bind<1>(i) = imageArray.bind<1>(info.height()-(i+1));
			        }
                    
                    exportImage(srcImageRange(newImageArray), vigra::ImageExportInfo(argv[2]));
                }
                else {
                    std::cout << "no gray scale image" << std::endl;
                }
            }
            catch (vigra::StdException & e) {
                std::cout << e.what() << std::endl;
                return 1;
            }
            
            return 0;
        }
    \endcode
    
    This code needs an infile and an outfile as arguments. For this example, just the 
    commented for-loop is important. The rest contains the code for
    \ref ImageInputOutput and is explained in this part of the Tutorial. We bind dimension 1
    to fix the y-coordinate. To mirror horizontal you have to fix the x-coordinate, so bind
    dimension 0. <br/>
    Here you can see what happens to an inputfile:

    \image html lenna_small.gif "inputfile"
    \image html lenna_mirror.gif "mirrored outputfile"

    A detailed example is given here:
    <a href="mirror_8cxx-example.html">mirror.cxx</a> 
    There you can mirror RGB-images as well and decide wheter to mirror horizontal or
    vertical.
    
    <hr>

    <h2> subarray(p,q) </h2>
    This method is part of the MultiArrayView-Class and creates a rectangular subarray of your
    array between the points p and q, where p is included, q not. Compared to the <dfn>bind
    </dfn>-method, subarray doesn't change the dimension.
    To give an example, let's say that you want to copy the upper-left subsquare of a 
    4x4-matrix (initialized with 1).

    \code
        // copy the upper-left subsquare of a 4x4-matrix
        vigra::MultiArray<2, int> _44Matrix(Shape2(4,4));
        _44Matrix.init(1);
        vigra::MultiArray<2, int> subsquare = _44Matrix.subarray(Shape2(0,0), Shape2(2,2));
    \endcode

    To determine the positions p and q, we use <dfn>Shape</dfn>. In this example we copy the 
    element with the x,y-coordinates from 0 to 1. Subarray can be used to set elements as
    well. We now set the lower half of the 4x4-matrix to 0.

    \code
       // change the elements of a subarray
       _44Matrix.subarray(Shape2(0,2),Shape2(4,4)) = 0;
    \endcode

    In Image Processing you can use <dfn>subarray</dfn> to create a subimage of a given image.
    In the next example we create a half-sized subimage with the middle part of the original
    image:
    <a href="subimage_tutorial_8cxx-example.html">subimage_tutorial.cxx</a> <br />
    The relevant part ot this code is shown here:

    \dontinclude subimage_tutorial.cxx
    \skip // write
    \until exportImage

    After writing the (here: gray scale) image data to an array we need to calculate the 
    coordinates of our subimage. In this case we want to cut out the middle part of the image. 
    Afterwards we write the subimage into a new array. Look at the results.

    \image html lenna_small.gif "inputfile"
    \image html lenna_sub.gif "subimage outputfile"
*/

/** \example mirror.cxx
    Mirror an image file (horizontal or vertical)
    <br>
    Usage: <TT>mirror infile outfile</TT>
*/

/** \example subimage_tutorial.cxx
    Create a half-sized subimage
    <br>
    Usage: <TT>mirror infile outfile</TT>
*/

/** \page ImageInputOutput Image Input Output
